/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import * as schemas$ from "../lib/schemas";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import { SecurityInput } from "../lib/security";
import * as models from "../models";

export class LobbyV2 extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Create a new lobby for an [application](https://hathora.dev/docs/concepts/hathora-entities#application). A lobby object is a wrapper around a [room](https://hathora.dev/docs/concepts/hathora-entities#room) object. With a lobby, you get additional functionality like configuring the visibility of the room, managing the state of a match, and retrieving a list of public lobbies to display to players.
     *
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async createLobbyDeprecated(
        security: models.CreateLobbyDeprecatedSecurity,
        createLobbyParams: models.CreateLobbyParams,
        appId?: string | undefined,
        roomId?: string | undefined,
        options?: RequestOptions
    ): Promise<models.CreateLobbyDeprecatedResponse> {
        const input$: models.CreateLobbyDeprecatedRequest = {
            createLobbyParams: createLobbyParams,
            appId: appId,
            roomId: roomId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.CreateLobbyDeprecatedRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.CreateLobbyParams, { explode: true });

        const pathParams$ = {
            appId: enc$.encodeSimple("appId", payload$.appId ?? this.options$.appId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/lobby/v2/{appId}/create")(pathParams$);

        const query$ = [
            enc$.encodeForm("roomId", payload$.roomId, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$: SecurityInput[][] = [
            [
                {
                    fieldName: "Authorization",
                    type: "http:bearer",
                    value: security?.playerAuth,
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "CreateLobbyDeprecated",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const doOptions = {
            context,
            errorCodes: ["400", "401", "402", "404", "422", "429", "4XX", "500", "5XX"],
        };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 201, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.CreateLobbyDeprecatedResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Lobby: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (
            this.matchResponse(response, [400, 401, 402, 404, 422, 429, 500], "application/json")
        ) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.ApiError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            const responseBody = await response.text();
            throw new models.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async createLocalLobby(
        security: models.CreateLocalLobbySecurity,
        requestBody: models.CreateLocalLobbyRequestBody,
        appId?: string | undefined,
        roomId?: string | undefined,
        options?: RequestOptions
    ): Promise<models.CreateLocalLobbyResponse> {
        const input$: models.CreateLocalLobbyRequest = {
            requestBody: requestBody,
            appId: appId,
            roomId: roomId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.CreateLocalLobbyRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            appId: enc$.encodeSimple("appId", payload$.appId ?? this.options$.appId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/lobby/v2/{appId}/create/local")(pathParams$);

        const query$ = [
            enc$.encodeForm("roomId", payload$.roomId, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$: SecurityInput[][] = [
            [
                {
                    fieldName: "Authorization",
                    type: "http:bearer",
                    value: security?.playerAuth,
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "CreateLocalLobby",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const doOptions = {
            context,
            errorCodes: ["400", "401", "402", "404", "422", "429", "4XX", "500", "5XX"],
        };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 201, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.CreateLocalLobbyResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Lobby: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (
            this.matchResponse(response, [400, 401, 402, 404, 422, 429, 500], "application/json")
        ) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.ApiError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            const responseBody = await response.text();
            throw new models.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async createPrivateLobby(
        security: models.CreatePrivateLobbySecurity,
        requestBody: models.CreatePrivateLobbyRequestBody,
        appId?: string | undefined,
        roomId?: string | undefined,
        options?: RequestOptions
    ): Promise<models.CreatePrivateLobbyResponse> {
        const input$: models.CreatePrivateLobbyRequest = {
            requestBody: requestBody,
            appId: appId,
            roomId: roomId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.CreatePrivateLobbyRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            appId: enc$.encodeSimple("appId", payload$.appId ?? this.options$.appId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/lobby/v2/{appId}/create/private")(pathParams$);

        const query$ = [
            enc$.encodeForm("roomId", payload$.roomId, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$: SecurityInput[][] = [
            [
                {
                    fieldName: "Authorization",
                    type: "http:bearer",
                    value: security?.playerAuth,
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "CreatePrivateLobby",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const doOptions = {
            context,
            errorCodes: ["400", "401", "402", "404", "422", "429", "4XX", "500", "5XX"],
        };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 201, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.CreatePrivateLobbyResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Lobby: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (
            this.matchResponse(response, [400, 401, 402, 404, 422, 429, 500], "application/json")
        ) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.ApiError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            const responseBody = await response.text();
            throw new models.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async createPublicLobby(
        security: models.CreatePublicLobbySecurity,
        requestBody: models.CreatePublicLobbyRequestBody,
        appId?: string | undefined,
        roomId?: string | undefined,
        options?: RequestOptions
    ): Promise<models.CreatePublicLobbyResponse> {
        const input$: models.CreatePublicLobbyRequest = {
            requestBody: requestBody,
            appId: appId,
            roomId: roomId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.CreatePublicLobbyRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            appId: enc$.encodeSimple("appId", payload$.appId ?? this.options$.appId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/lobby/v2/{appId}/create/public")(pathParams$);

        const query$ = [
            enc$.encodeForm("roomId", payload$.roomId, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$: SecurityInput[][] = [
            [
                {
                    fieldName: "Authorization",
                    type: "http:bearer",
                    value: security?.playerAuth,
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "CreatePublicLobby",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const doOptions = {
            context,
            errorCodes: ["400", "401", "402", "404", "422", "429", "4XX", "500", "5XX"],
        };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 201, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.CreatePublicLobbyResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Lobby: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (
            this.matchResponse(response, [400, 401, 402, 404, 422, 429, 500], "application/json")
        ) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.ApiError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            const responseBody = await response.text();
            throw new models.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get details for a lobby.
     *
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async getLobbyInfo(
        roomId: string,
        appId?: string | undefined,
        options?: RequestOptions
    ): Promise<models.GetLobbyInfoResponse> {
        const input$: models.GetLobbyInfoRequest = {
            roomId: roomId,
            appId: appId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetLobbyInfoRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            appId: enc$.encodeSimple("appId", payload$.appId ?? this.options$.appId, {
                explode: false,
                charEncoding: "percent",
            }),
            roomId: enc$.encodeSimple("roomId", payload$.roomId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/lobby/v2/{appId}/info/{roomId}")(pathParams$);

        const query$ = "";

        const context = { operationID: "GetLobbyInfo", oAuth2Scopes: [], securitySource: null };

        const doOptions = { context, errorCodes: ["404", "4XX", "5XX"] };
        const request = this.createRequest$(
            { method: "GET", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.GetLobbyInfoResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Lobby: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, 404, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.ApiError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            const responseBody = await response.text();
            throw new models.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get all active lobbies for a an [application](https://hathora.dev/docs/concepts/hathora-entities#application). Filter by optionally passing in a `region`. Use this endpoint to display all public lobbies that a player can join in the game client.
     *
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async listActivePublicLobbiesDeprecatedV2(
        appId?: string | undefined,
        region?: models.Region | undefined,
        options?: RequestOptions
    ): Promise<models.ListActivePublicLobbiesDeprecatedV2Response> {
        const input$: models.ListActivePublicLobbiesDeprecatedV2Request = {
            appId: appId,
            region: region,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                models.ListActivePublicLobbiesDeprecatedV2Request$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            appId: enc$.encodeSimple("appId", payload$.appId ?? this.options$.appId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/lobby/v2/{appId}/list/public")(pathParams$);

        const query$ = [
            enc$.encodeForm("region", payload$.region, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const context = {
            operationID: "ListActivePublicLobbiesDeprecatedV2",
            oAuth2Scopes: [],
            securitySource: null,
        };

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            { method: "GET", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.ListActivePublicLobbiesDeprecatedV2Response$.inboundSchema.parse({
                        ...responseFields$,
                        classes: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new models.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Set the state of a lobby. State is intended to be set by the server and must be smaller than 1MB. Use this endpoint to store match data like live player count to enforce max number of clients or persist end-game data (i.e. winner or final scores).
     *
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async setLobbyState(
        setLobbyStateParams: models.SetLobbyStateParams,
        roomId: string,
        appId?: string | undefined,
        options?: RequestOptions
    ): Promise<models.SetLobbyStateResponse> {
        const input$: models.SetLobbyStateRequest = {
            setLobbyStateParams: setLobbyStateParams,
            roomId: roomId,
            appId: appId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.SetLobbyStateRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.SetLobbyStateParams, { explode: true });

        const pathParams$ = {
            appId: enc$.encodeSimple("appId", payload$.appId ?? this.options$.appId, {
                explode: false,
                charEncoding: "percent",
            }),
            roomId: enc$.encodeSimple("roomId", payload$.roomId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/lobby/v2/{appId}/setState/{roomId}")(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "SetLobbyState",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["401", "404", "422", "4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.SetLobbyStateResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Lobby: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, [401, 404, 422], "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return models.ApiError$.inboundSchema.parse({
                        ...responseFields$,
                        ...val$,
                    });
                },
                "Response validation failed"
            );
            throw result;
        } else {
            const responseBody = await response.text();
            throw new models.SDKError("Unexpected API response", response, responseBody);
        }
    }
}
